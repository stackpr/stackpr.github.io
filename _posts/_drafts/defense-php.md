---
title: In Defense of PHP
layout: post
category: blog
tech:
- PHP
permalink: /blog/2012/07/23/defense-php
published: false

---
{% include JB/setup %}
<div id="node-178" class="node node-blog node-promoted node-unpublished">
  <div class="content clearfix">
    <div class="field field-name-body field-type-text-with-summary field-label-hidden"><div class="field-items"><div class="field-item even"><p>Most PHP manifestos (<a href="http://www.itsabacus.com/blog/2011/01/the-unbeatable-benefits-of-php/">including this nice defense</a>) boil down to the same points. PHP is free, is easy to learn, is quick to build with, runs fast, and has a vibrant community. Unfortunately, those defenses talk past the criticisms that generally focus on the language's architecture (<a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">including this nice attack</a>). There is actually very little disagreement in the flame wars since the sides focus on different elements entirely, and yet skilled programmers fall on either side after weighing the pros and cons. After 14 years of solving some pretty complex problems with PHP, I struggle with the concept that it is a tragically-flawed or inadequate programming language. Given the widespread and dramatic uses of PHP, perhaps we as PHP programmers need to take a little more pride in our language and explain why it works.</p>
<p><a href="http://www.phpclasses.org/blog/post/208-5-Reasons-Why-the-Web-Platform-War-is-Over-PHP-Won-with-75-says-Google.html">5 Reasons Why the Web Platform War is Over: PHP Won with 75% says Google - PHP Classes blog - PHP Classes</a></p>
<h2>
	The Right Tool?</h2>
<p>Plenty of anti-PHP rants talk about how PHP is a <a href="http://www.flickr.com/photos/raindrift/7095238893/">bad tool</a> and how the fact that people use it does not make it a good tool. Instead, they insist that you should use the "right tool" for the right job.</p>
<h2>
	Namespaces</h2>
<p>Complaints of too many global functions in PHP.</p>
<p>Supposedly, you get several benefits from namespaces:</p>
<ol><li>
		Avoid naming conflicts</li>
	<li>
		Keeps it organized</li>
	<li>
		Fewer keystrokes</li>
	<li>
		Quickly inform the compiler which code to reference</li>
</ol><p>References</p>
<ol><li>
		<a href="http://www.gotw.ca/publications/mill08.htm">Introduction of ambiguity</a></li>
	<li>
		<a href="http://www.simple-talk.com/dotnet/.net-framework/defining-.net-components-with-namespaces/#two">.Net use of namespaces</a></li>
	<li>
		<a href="http://jobinjohn.blogspot.com/2011/06/namespace-in-c-and-its-advantages.html">Does not inherently solve naming conflicts</a></li>
	<li>
		<a href="http://www.dotnetspider.com/tutorials/DotNet-Tutorial-274.aspx">Which namespace are you pulling from?</a></li>
</ol><h2>
	Counting Keystrokes</h2>
<p> </p>
<h2>
	Dummy Programmers</h2>
<p> </p>
<h2>
	Apples to Apples</h2>
<p><a href="http://social.msdn.microsoft.com/forums/en-US/netfxbcl/thread/e7ca66a9-aac5-47b7-b41f-01b1f1543f38/">The .Net interpreter is (or at least was) written in C++.</a></p>
<h2>
	References</h2>
<ol><li>
		<a href="http://en.wikipedia.org/wiki/Imperative_programming">Imperative Programming</a> &gt; Procedural Programming &gt; Structured Programming &gt; Modular Programming &gt; Object-Oriented Programming</li>
	<li>
		<a href="http://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> = web application frameworks that separate business logic from application logic</li>
	<li>
		<a href="http://en.wikipedia.org/wiki/Reflective_programming">Reflective Programming</a></li>
	<li>
		<a href="http://en.wikipedia.org/wiki/Programming_paradigm">http://en.wikipedia.org/wiki/Programming_paradigm</a></li>
	<li>
		<a href="http://news.php.net/php.internals/58385">Why doesn't PHP change?</a></li>
	<li>
		<a href="http://steve-yegge.blogspot.com/2008/05/dynamic-languages-strike-back.html">Dynamic language presentation</a></li>
</ol></div></div></div>  </div>
</div>
